const e=Promise.withResolvers||function(){var e,t,s=new this((s,n)=>{e=s,t=n});return{resolve:e,reject:t,promise:s}};var t=e.bind(Promise),s=e=>{const t=new Int32Array(1);return()=>t[0]++},n="fc260aad-4404-43b8-ae9d-2c06554bb294";const{isArray:r}=Array,a=e=>e;class o extends Worker{#e;#t;constructor(e,t){super(e,t),this.#e=s(),this.#t=new Map,t.onsend||(t.onsend=a),super.addEventListener("message",async e=>{const{data:s}=e;if(r(s)&&s[0]===n){e.stopImmediatePropagation(),e.preventDefault();const[n,r]=s[1],a=this.#t.get(n);this.#t.delete(n),a(await t.onsend(r))}})}send(e,...s){const r=this.#e(),{promise:a,resolve:o}=t();return this.#t.set(r,o),super.postMessage([n,[r,e]],...s),a}}let{SharedArrayBuffer:c}=globalThis;try{new c(4,{maxByteLength:8})}catch(e){c=class extends ArrayBuffer{get growable(){return super.resizable}grow(e){super.resize(e)}}}const i=2*Int32Array.BYTES_PER_ELEMENT;let l=!0;try{crypto.randomUUID()}catch(e){l=!1}const u=l?()=>crypto.randomUUID():()=>(Date.now()+Math.random()).toString(36);var h=({initByteLength:e=1024,maxByteLength:t=8192})=>new c(i+e,{maxByteLength:i+t});let p=0;const f=p++,g=p++,d=p++,y=p++,w=p++,b=p++,m=p++,v=p++,A=p++,k=p++,S=p++,U=p++,x=p++,B=p++,M=p++,E=p++,L=p++,T=p++,I=p++,O=p++,R=p++,D=p++,P=p++,N=p++,q=p++,F=p++,j=p++,z=p++;const C=globalThis.ImageData||class{};class _{static push(e,t){e.sync(!1),e._(t,t.length)}constructor(e,t){const s=[];this.l=0,this.o=s,this.v=new Uint8Array(e,t),this.push=s.push.bind(s)}get length(){return this.l+this.o.length}sync(e){const t=this.o,s=t.length;s&&this._(e?t:t.splice(0),s)}_(e,t){const{buffer:s,byteOffset:n}=this.v,r=this.l;this.l+=t,t+=n+r,s.byteLength<t&&s.grow(t),this.v.set(e,r)}}const W=new Map(Reflect.ownKeys(Symbol).map(e=>[Symbol[e],`@${String(e)}`])),J=e=>W.get(e)||((e,t)=>void 0===t?"?":void 0===Symbol.keyFor(e)?`!${t}`:`#${t}`)(e,e.description),$=Object.defineProperty,H=Array.isArray,K=ArrayBuffer.isView,V=new TextDecoder,X=new TextEncoder,Y=new ArrayBuffer(8),G=new DataView(Y),Q=new Uint8Array(Y),{getPrototypeOf:Z}=Object,{construct:ee}=Reflect,{toStringTag:te}=Symbol,se=(e,t=e[te])=>t in globalThis?t:se(ee(Z(e.constructor),[0])),{isNaN:ne,isFinite:re,isInteger:ae}=Number,{ownKeys:oe}=Reflect,{is:ce}=Object,ie=(e,t,s)=>{const n=s.get(e),r=!n;return r?(G.setUint32(0,t.length,!0),s.set(e,[Q[0],Q[1],Q[2],Q[3]])):t.push(z,n[0],n[1],n[2],n[3]),r},le=(e,t,s)=>{G.setUint32(0,s,!0),e.push(t,Q[0],Q[1],Q[2],Q[3])},ue=(e,t,s)=>{switch(typeof e){case"number":e&&re(e)?ae(e)&&e<256&&-1<e?t.push(b,e):(G.setFloat64(0,e,!0),t.push(w,Q[0],Q[1],Q[2],Q[3],Q[4],Q[5],Q[6],Q[7])):ne(e)?t.push(m):e?t.push(e<0?A:v):t.push(ce(e,0)?k:S);break;case"object":switch(!0){case null===e:t.push(y);break;case!ie(e,t,s):break;case H(e):{const n=e.length;le(t,E,n);for(let r=0;r<n;r++)ue(e[r],t,s);break}case K(e):if(t.push(N),ue(se(e),t,s),e=e.buffer,!ie(e,t,s))break;case e instanceof ArrayBuffer:{const s=new Uint8Array(e);le(t,L,s.length),pe(t,s);break}case e instanceof Date:t.push(T),ue(e.getTime(),t,s);break;case e instanceof Map:le(t,O,e.size);for(const[n,r]of e)ue(n,t,s),ue(r,t,s);break;case e instanceof Set:le(t,P,e.size);for(const n of e)ue(n,t,s);break;case e instanceof Error:t.push(I),ue(e.name,t,s),ue(e.message,t,s),ue(e.stack,t,s);break;case e instanceof C:t.push(q),ue(e.data,t,s),ue(e.width,t,s),ue(e.height,t,s),ue(e.colorSpace,t,s),ue(e.pixelFormat,t,s);break;case e instanceof RegExp:t.push(D),ue(e.source,t,s),ue(e.flags,t,s);break;case e instanceof File:t.push(j),ue(e.name,t,s),ue(e.lastModified,t,s);case e instanceof Blob:{const n=e.size;t.push(F),ue(e.type,t,s),ue(n,t,s);const r=t.length;pe(t,new Uint8Array(n)),he.push(e.arrayBuffer().then(e=>[r,e]));break}default:if("toJSON"in e){const n=e.toJSON();ue(n===e?null:n,t,s)}else{const n=oe(e),r=n.length;le(t,R,r);for(let a=0;a<r;a++){const r=n[a];ue(r,t,s),ue(e[r],t,s)}}}break;case"string":if(ie(e,t,s)){const s=X.encode(e);le(t,B,s.length),pe(t,s)}break;case"boolean":t.push(e?g:f);break;case"symbol":t.push(M),ue(J(e),t,s);break;case"bigint":{let s=U;9223372036854775807n<e?(G.setBigUint64(0,e,!0),s=x):G.setBigInt64(0,e,!0),t.push(s,Q[0],Q[1],Q[2],Q[3],Q[4],Q[5],Q[6],Q[7]);break}default:t.push(d)}},he=[];let pe=(e,t)=>{for(let s=e.push,n=0,r=t.length;n<r;n+=32767)s.apply(e,t.subarray(n,n+32767))};const fe=({byteOffset:e=0,Array:t=_}={})=>(s,n)=>{const r=new t(n,e);pe=t.push,ue(s,r,new Map);const a=r.length;return r.sync(!0),he.length?Promise.all(he.splice(0)).then(t=>{const s=new Uint8Array(n,e);for(const[e,n]of t)s.set(new Uint8Array(n),e);return a}):a},ge=(e,t,s)=>{const n=new Int32Array(e),r=(t.encoder??fe)({byteOffset:i}),a=e=>{n[1]=e,n[0]=1};return async({data:s})=>(t=>{const s=r(t,e);return"number"==typeof s?a(s):s.then(a)})(await t.onsync(s))},de=e=>{switch(typeof e){case"symbol":case"function":return!1}return!0},ye=(e,t)=>{const s={};for(const e in t){const n=t[e];de(e)&&de(n)&&(s[e]=n)}return[e,s]},we=(e,t,s)=>{const n=new URL(e,location.href);return n.searchParams.set("reflected",t),[n,{...s,type:"module"}]},be="async";let me=class extends o{constructor(e,t,s){const n=u(),r=new BroadcastChannel(n),a=h(t),o=new Int32Array(a),c=ge(a,t);r.addEventListener("message",async({data:[e,t]})=>{await c({data:t}),r.postMessage([e,new Uint8Array(a,i,o[1])])}),super(...we(e,be,t)),super.addEventListener("message",()=>s(this),{once:!0}),super.postMessage(ye(a,t).concat(n))}get channel(){return be}};const ve=new Map,Ae=new BroadcastChannel(n);Ae.addEventListener("message",async({data:[e,t]})=>{if("request"===e){const[e,[s,n]]=t,r=ve.get(n);if(r){const t=r.get(s);r.delete(s),Ae.postMessage(["response",[e,await t]])}}});const{promise:ke,resolve:Se}=t();let Ue=!0;const xe=(e,t)=>{let s,n=!0,{url:r}=t;e.getRegistration(r).then(s=>s??e.register(r,t)).then(function a(o){const{controller:c}=e;if(n=n&&!!c,s=o.installing||o.waiting||o.active,!s)return xe(e,t);if("activated"===s.state){if(n){if(c.scriptURL===r)return Se();o.unregister()}location.reload()}else s.addEventListener("statechange",()=>a(o),{once:!0})})};let Be=class extends o{#s;constructor(e,s,n){if(Ue){Ue=!1;let{serviceWorker:t}=s;if(!t)return new me(e,s,n);"string"==typeof t&&(t={url:t}),t.url=new URL(t.url,location.href).href,xe(navigator.serviceWorker,t)}const r=u(),a=new BroadcastChannel(r),o=h(s),c=new Map,l=new Int32Array(o),p=ge(o,s);ve.set(r,c),a.addEventListener("message",async({data:[e,s]})=>{const{promise:n,resolve:r}=t();c.set(e,n),await p({data:s}),r(new Uint8Array(o,i,l[1]))}),super(...we(e,"xhr",s)),super.addEventListener("message",()=>n(this),{once:!0}),super.postMessage(ye(o,s).concat(r)),this.#s=r}terminate(){ve.delete(this.#s),super.terminate()}get channel(){return"xhr"}};const Me=(e,t,s)=>(e.set(t,s),s),Ee=e=>{Q[0]=e[Ie++],Q[1]=e[Ie++],Q[2]=e[Ie++],Q[3]=e[Ie++],Q[4]=e[Ie++],Q[5]=e[Ie++],Q[6]=e[Ie++],Q[7]=e[Ie++]},Le=e=>(Q[0]=e[Ie++],Q[1]=e[Ie++],Q[2]=e[Ie++],Q[3]=e[Ie++],G.getUint32(0,!0)),Te=(e,t)=>{switch(e[Ie++]){case w:return Ee(e),G.getFloat64(0,!0);case b:return e[Ie++];case R:{const s=Me(t,Ie-1,{});for(let n=0,r=Le(e);n<r;n++)s[Te(e,t)]=Te(e,t);return s}case E:{const s=Me(t,Ie-1,[]);for(let n=0,r=Le(e);n<r;n++)s.push(Te(e,t));return s}case N:{const s=Ie-1,n=Te(e,t);return Me(t,s,new globalThis[n](Te(e,t)))}case L:{const s=Ie-1,n=Le(e);return Me(t,s,e.slice(Ie,Ie+=n).buffer)}case B:{const s=Ie-1,n=Le(e);return Me(t,s,V.decode(e.slice(Ie,Ie+=n)))}case T:return Me(t,Ie-1,new Date(Te(e,t)));case O:{const s=Me(t,Ie-1,new Map);for(let n=0,r=Le(e);n<r;n++)s.set(Te(e,t),Te(e,t));return s}case P:{const s=Me(t,Ie-1,new Set);for(let n=0,r=Le(e);n<r;n++)s.add(Te(e,t));return s}case I:{const s=Te(e,t),n=Te(e,t),r=Te(e,t),a=new(globalThis[s]||Error)(n);return Me(t,Ie-1,$(a,"stack",{value:r}))}case q:{const s=Te(e,t),n=Te(e,t),r=Te(e,t),a=Te(e,t),o=Te(e,t);return Me(t,Ie-1,new C(s,n,r,{colorSpace:a,pixelFormat:o}))}case D:{const s=Te(e,t),n=Te(e,t);return Me(t,Ie-1,new RegExp(s,n))}case f:return!1;case g:return!0;case m:return NaN;case v:return 1/0;case A:return-1/0;case k:return 0;case S:return-0;case y:return null;case U:return Ee(e),G.getBigInt64(0,!0);case x:return Ee(e),G.getBigUint64(0,!0);case M:return(e=>{switch(e[0]){case"@":return Symbol[e.slice(1)];case"#":return Symbol.for(e.slice(1));case"!":return Symbol(e.slice(1));default:return Symbol()}})(Te(e,t));case z:return t.get(Le(e));case F:{const s=Te(e,t),n=Te(e,t);return Me(t,Ie-1,new Blob([e.slice(Ie,Ie+=n)],{type:s}))}case j:{const s=Ie-1,n=Te(e,t),r=Te(e,t),a=Te(e,t);return Me(t,s,new File([a],n,{type:a.type,lastModified:r}))}default:return}};let Ie=0;const Oe=({byteOffset:e=0}={})=>(t,s)=>{return n=new Uint8Array(s,e,t),Ie=0,Te(n,new Map);var n},{isArray:Re}=Array;const{parse:De,stringify:Pe}=JSON,{promise:Ne,resolve:qe}=t();addEventListener("message",({data:[e,t,s]})=>qe([t,s]),{once:!0});const Fe="xhr";var je="importScripts"in globalThis?e=>Ne.then(([t,r])=>(postMessage(1),((e,t)=>{const n=new BroadcastChannel(e),r=s(),a=(t.decoder??Oe)({byteOffset:0}),{serviceWorker:o}=t;return(s,...c)=>{const i=r();n.postMessage([i,s],...c);const l=new XMLHttpRequest;l.open("POST",o,!1),l.setRequestHeader("Content-Type","application/json"),l.send(Pe([i,e]));const{length:u,buffer:h}=new Uint8Array(De(l.responseText));return t.onsync(u?a(u,h):void 0)}})(r,(e=>(addEventListener("message",async t=>{const{data:s}=t;if(Re(s)&&s[0]===n){t.stopImmediatePropagation(),t.preventDefault();const[r,a]=s[1];postMessage([n,[r,await e.onsend(a)]])}}),e))({...t,...e})))):(e,s)=>{const{promise:n,resolve:r}=t();return new Be(e,s,r)instanceof me?n:ke.then(()=>n)};export{Fe as channel,je as default};

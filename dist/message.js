const e=Promise.withResolvers||function(){var e,t,s=new this((s,r)=>{e=s,t=r});return{resolve:e,reject:t,promise:s}};var t=e.bind(Promise);const{notify:s,store:r}=Atomics,n=2*Int32Array.BYTES_PER_ELEMENT,a=e=>{switch(typeof e){case"symbol":case"function":return!1}return!0};class o extends globalThis.Worker{constructor(e,t,o){const{port1:c,port2:i}=new MessageChannel,g=(({initByteLength:e=1024,maxByteLength:t=8192})=>new SharedArrayBuffer(n+e,{maxByteLength:n+t}))(t);c.addEventListener("message",((e,t)=>{const a=new Int32Array(e);return async({data:o})=>{const c=await t.ondata(o),i=c.length,g=n+c.buffer.byteLength;e.byteLength<g&&e.grow(g),a.set(c,2),r(a,1,i),r(a,0,1),s(a,0)}})(g,t)),c.start(),super(...((e,t,s)=>{const r=new URL(e,location.href);return r.searchParams.set("reflected",t),[r,{...s,type:"module"}]})(e,"message",t)),super.addEventListener("message",()=>o(this),{once:!0}),super.postMessage(((e,t)=>{const s={};for(const e in t){const r=t[e];a(e)&&a(r)&&(s[e]=r)}return[e,s]})(g,t),[i])}get channel(){return"message"}}const{load:c,store:i,wait:g}=Atomics,{promise:m,resolve:u}=t(),h="message";var l=((e,t)=>(addEventListener("message",t,{once:!0}),t=>e.then(([e,s,r])=>(postMessage(1),((e,t,s)=>(r,...n)=>(e.postMessage(r,...n),g(t,0,0),i(t,0,0),s.ondata(t.subarray(2,2+c(t,1)),...n)))(r,new Int32Array(e),{...s,...t})))))(m,({data:[e,t],ports:[s]})=>u([e,t,s])),d="importScripts"in globalThis?l:(e,s)=>{const{promise:r,resolve:n}=t();return new o(e,s,n),r};export{h as channel,d as default};

const e=Promise.withResolvers||function(){var e,t,s=new this((s,n)=>{e=s,t=n});return{resolve:e,reject:t,promise:s}};var t=e.bind(Promise),s="fc260aad-4404-43b8-ae9d-2c06554bb294";const{isArray:n}=Array,r=e=>e;class a extends Worker{#e;#t;constructor(e,t){super(e,t),this.#e=(()=>{const e=new Int32Array(1);return()=>e[0]++})(),this.#t=new Map,t.onsend||(t.onsend=r),super.addEventListener("message",async e=>{const{data:r}=e;if(n(r)&&r[0]===s){e.stopImmediatePropagation(),e.preventDefault();const[s,n]=r[1],a=this.#t.get(s);this.#t.delete(s),a(await t.onsend(n))}})}send(e,...n){const r=this.#e(),{promise:a,resolve:o}=t();return this.#t.set(r,o),super.postMessage([s,[r,e]],...n),a}}let o=0;const c=o++,i=o++,u=o++,l=o++,h=o++,p=o++,f=o++,y=o++,g=o++,b=o++,d=o++,w=o++,m=o++,v=o++,A=o++,k=o++,S=o++,B=o++,E=o++,M=o++,U=o++,x=o++,I=o++,L=o++,O=o++,T=o++,P=o++,D=o++;const F=globalThis.ImageData||class{};class N{static push(e,t){e.sync(!1),e._(t,t.length)}constructor(e,t){const s=[];this.l=0,this.o=s,this.v=new Uint8Array(e,t),this.push=s.push.bind(s)}get length(){return this.l+this.o.length}sync(e){const t=this.o,s=t.length;s&&this._(e?t:t.splice(0),s)}_(e,t){const{buffer:s,byteOffset:n}=this.v,r=this.l;this.l+=t,t+=n+r,s.byteLength<t&&s.grow(t),this.v.set(e,r)}}const R=new Map(Reflect.ownKeys(Symbol).map(e=>[Symbol[e],`@${String(e)}`])),j=e=>R.get(e)||((e,t)=>void 0===t?"?":void 0===Symbol.keyFor(e)?`!${t}`:`#${t}`)(e,e.description),q=Object.defineProperty,_=Array.isArray,z=ArrayBuffer.isView,$=new TextDecoder,J=new TextEncoder,K=new ArrayBuffer(8),V=new DataView(K),C=new Uint8Array(K),{getPrototypeOf:W}=Object,{construct:Y}=Reflect,{toStringTag:G}=Symbol,H=(e,t=e[G])=>t in globalThis?t:H(Y(W(e.constructor),[0])),{isNaN:Q,isFinite:X,isInteger:Z}=Number,{ownKeys:ee}=Reflect,{is:te}=Object,se=(e,t,s)=>{const n=s.get(e),r=!n;return r?(V.setUint32(0,t.length,!0),s.set(e,[C[0],C[1],C[2],C[3]])):t.push(D,n[0],n[1],n[2],n[3]),r},ne=(e,t,s)=>{V.setUint32(0,s,!0),e.push(t,C[0],C[1],C[2],C[3])},re=(e,t,s)=>{switch(typeof e){case"number":e&&X(e)?Z(e)&&e<256&&-1<e?t.push(p,e):(V.setFloat64(0,e,!0),t.push(h,C[0],C[1],C[2],C[3],C[4],C[5],C[6],C[7])):Q(e)?t.push(f):e?t.push(e<0?g:y):t.push(te(e,0)?b:d);break;case"object":switch(!0){case null===e:t.push(l);break;case!se(e,t,s):break;case _(e):{const n=e.length;ne(t,k,n);for(let r=0;r<n;r++)re(e[r],t,s);break}case z(e):if(t.push(L),re(H(e),t,s),e=e.buffer,!se(e,t,s))break;case e instanceof ArrayBuffer:{const s=new Uint8Array(e);ne(t,S,s.length),oe(t,s);break}case e instanceof Date:t.push(B),re(e.getTime(),t,s);break;case e instanceof Map:ne(t,M,e.size);for(const[n,r]of e)re(n,t,s),re(r,t,s);break;case e instanceof Set:ne(t,I,e.size);for(const n of e)re(n,t,s);break;case e instanceof Error:t.push(E),re(e.name,t,s),re(e.message,t,s),re(e.stack,t,s);break;case e instanceof F:t.push(O),re(e.data,t,s),re(e.width,t,s),re(e.height,t,s),re(e.colorSpace,t,s),re(e.pixelFormat,t,s);break;case e instanceof RegExp:t.push(x),re(e.source,t,s),re(e.flags,t,s);break;case e instanceof File:t.push(P),re(e.name,t,s),re(e.lastModified,t,s);case e instanceof Blob:{const n=e.size;t.push(T),re(e.type,t,s),re(n,t,s);const r=t.length;oe(t,new Uint8Array(n)),ae.push(e.arrayBuffer().then(e=>[r,e]));break}default:if("toJSON"in e){const n=e.toJSON();re(n===e?null:n,t,s)}else{const n=ee(e),r=n.length;ne(t,U,r);for(let a=0;a<r;a++){const r=n[a];re(r,t,s),re(e[r],t,s)}}}break;case"string":if(se(e,t,s)){const s=J.encode(e);ne(t,v,s.length),oe(t,s)}break;case"boolean":t.push(e?i:c);break;case"symbol":t.push(A),re(j(e),t,s);break;case"bigint":{let s=w;9223372036854775807n<e?(V.setBigUint64(0,e,!0),s=m):V.setBigInt64(0,e,!0),t.push(s,C[0],C[1],C[2],C[3],C[4],C[5],C[6],C[7]);break}default:t.push(u)}},ae=[];let oe=(e,t)=>{for(let s=e.push,n=0,r=t.length;n<r;n+=32767)s.apply(e,t.subarray(n,n+32767))};const ce=({byteOffset:e=0,Array:t=N}={})=>(s,n)=>{const r=new t(n,e);oe=t.push,re(s,r,new Map);const a=r.length;return r.sync(!0),ae.length?Promise.all(ae.splice(0)).then(t=>{const s=new Uint8Array(n,e);for(const[e,n]of t)s.set(new Uint8Array(n),e);return a}):a},ie=2*Int32Array.BYTES_PER_ELEMENT;try{crypto.randomUUID()}catch(e){}const{notify:ue,store:le}=Atomics,he=(e,t,s)=>{const n=new Int32Array(e),r=(t.encoder??ce)({byteOffset:ie}),a=e=>{le(n,1,e),le(n,0,1),ue(n,0)};return async({data:s})=>(t=>{const s=r(t,e);return"number"==typeof s?a(s):s.then(a)})(await t.onsync(s))},pe=e=>{switch(typeof e){case"symbol":case"function":return!1}return!0},fe="message";var ye=(e=>(s,n)=>{const{promise:r,resolve:a}=t();return new e(s,n,a),r})(class extends a{constructor(e,t,s){const{port1:n,port2:r}=new MessageChannel,a=(({initByteLength:e=1024,maxByteLength:t=8192})=>new SharedArrayBuffer(ie+e,{maxByteLength:ie+t}))(t);n.addEventListener(fe,he(a,t)),n.start(),super(...((e,t,s)=>{const n=new URL(e,location.href);return n.searchParams.set("reflected",t),[n,{...s,type:"module"}]})(e,fe,t)),super.addEventListener(fe,()=>s(this),{once:!0}),super.postMessage(((e,t)=>{const s={};for(const e in t){const n=t[e];pe(e)&&pe(n)&&(s[e]=n)}return[e,s]})(a,t),[r])}get channel(){return fe}});const ge=(e,t,s)=>(e.set(t,s),s),be=e=>{C[0]=e[me++],C[1]=e[me++],C[2]=e[me++],C[3]=e[me++],C[4]=e[me++],C[5]=e[me++],C[6]=e[me++],C[7]=e[me++]},de=e=>(C[0]=e[me++],C[1]=e[me++],C[2]=e[me++],C[3]=e[me++],V.getUint32(0,!0)),we=(e,t)=>{switch(e[me++]){case h:return be(e),V.getFloat64(0,!0);case p:return e[me++];case U:{const s=ge(t,me-1,{});for(let n=0,r=de(e);n<r;n++)s[we(e,t)]=we(e,t);return s}case k:{const s=ge(t,me-1,[]);for(let n=0,r=de(e);n<r;n++)s.push(we(e,t));return s}case L:{const s=me-1,n=we(e,t);return ge(t,s,new globalThis[n](we(e,t)))}case S:{const s=me-1,n=de(e);return ge(t,s,e.slice(me,me+=n).buffer)}case v:{const s=me-1,n=de(e);return ge(t,s,$.decode(e.slice(me,me+=n)))}case B:return ge(t,me-1,new Date(we(e,t)));case M:{const s=ge(t,me-1,new Map);for(let n=0,r=de(e);n<r;n++)s.set(we(e,t),we(e,t));return s}case I:{const s=ge(t,me-1,new Set);for(let n=0,r=de(e);n<r;n++)s.add(we(e,t));return s}case E:{const s=we(e,t),n=we(e,t),r=we(e,t),a=new(globalThis[s]||Error)(n);return ge(t,me-1,q(a,"stack",{value:r}))}case O:{const s=we(e,t),n=we(e,t),r=we(e,t),a=we(e,t),o=we(e,t);return ge(t,me-1,new F(s,n,r,{colorSpace:a,pixelFormat:o}))}case x:{const s=we(e,t),n=we(e,t);return ge(t,me-1,new RegExp(s,n))}case c:return!1;case i:return!0;case f:return NaN;case y:return 1/0;case g:return-1/0;case b:return 0;case d:return-0;case l:return null;case w:return be(e),V.getBigInt64(0,!0);case m:return be(e),V.getBigUint64(0,!0);case A:return(e=>{switch(e[0]){case"@":return Symbol[e.slice(1)];case"#":return Symbol.for(e.slice(1));case"!":return Symbol(e.slice(1));default:return Symbol()}})(we(e,t));case D:return t.get(de(e));case T:{const s=we(e,t),n=we(e,t);return ge(t,me-1,new Blob([e.slice(me,me+=n)],{type:s}))}case P:{const s=me-1,n=we(e,t),r=we(e,t),a=we(e,t);return ge(t,s,new File([a],n,{type:a.type,lastModified:r}))}default:return}};let me=0;const ve=({byteOffset:e=0}={})=>(t,s)=>{return n=new Uint8Array(s,e,t),me=0,we(n,new Map);var n},{isArray:Ae}=Array;const{load:ke,store:Se,wait:Be}=Atomics,{promise:Ee,resolve:Me}=t(),Ue="message";var xe=((e,t)=>(addEventListener("message",t,{once:!0}),t=>e.then(([e,n,r])=>(postMessage(1),((e,t,s)=>{const n=(s.decoder??ve)({byteOffset:ie}),{buffer:r}=t;return(a,...o)=>{e.postMessage(a,...o),Be(t,0,0),Se(t,0,0);const c=ke(t,1);return s.onsync(c?n(c,r):void 0)}})(r,new Int32Array(e),(e=>(addEventListener("message",async t=>{const{data:n}=t;if(Ae(n)&&n[0]===s){t.stopImmediatePropagation(),t.preventDefault();const[r,a]=n[1];postMessage([s,[r,await e.onsend(a)]])}}),e))({...n,...t}))))))(Ee,({data:[e,t],ports:[s]})=>Me([e,t,s])),Ie="importScripts"in globalThis?xe:ye;export{Ue as channel,Ie as default};

const e=Promise.withResolvers||function(){var e,t,n=new this((n,r)=>{e=n,t=r});return{resolve:e,reject:t,promise:n}};var t=e.bind(Promise);const n=2*Int32Array.BYTES_PER_ELEMENT,r=e=>{switch(typeof e){case"symbol":case"function":return!1}return!0};let{SharedArrayBuffer:s}=globalThis;try{new s(4,{maxByteLength:8})}catch(e){s=class extends ArrayBuffer{get growable(){return super.resizable}grow(e){super.resize(e)}}}const a=new Map,o=new BroadcastChannel("reflected-0123456789");o.addEventListener("message",async({data:[e,t]})=>{if("request"===e){const[e,[n,r]]=t,s=a.get(r);if(s){const t=s.get(n);t&&(s.delete(n),o.postMessage(["response",[e,await t]]))}}});const{promise:c,resolve:i}=t();let l=!0;class u extends globalThis.Worker{#e=crypto.randomUUID();constructor(e,o,c){if(l){l=!1;let{serviceWorker:e}=o;"string"==typeof e&&(e={url:e}),e.url=new URL(e.url,location.href).href,((e,t)=>{let n,r=!0,{url:s}=t;e.getRegistration(s).then(n=>n??e.register(s,t)).then(function t(a){const{controller:o}=e;if(r=r&&!!o,n=a.installing||a.waiting||a.active,"activated"===n.state){if(r){if(o.scriptURL===s)return i();a.unregister()}location.reload()}else n.addEventListener("statechange",()=>t(a),{once:!0})})})(navigator.serviceWorker,e)}const u=crypto.randomUUID(),d=new BroadcastChannel(u),g=(({initByteLength:e=1024,maxByteLength:t=8192})=>new s(n+e,{maxByteLength:n+t}))(o),h=new Map,p=new Int32Array(g),y=((e,t)=>{const r=new Int32Array(e);return async({data:s})=>{const a=await t.ondata(s),o=a.length,c=n+a.buffer.byteLength;e.byteLength<c&&e.grow(c),r.set(a,2),r[1]=o,r[0]=1}})(g,o);a.set(u,h),d.addEventListener("message",async({data:[e,n]})=>{const{promise:r,resolve:s}=t();h.set(e,r),await y({data:n}),s(p.slice(0,2+p[1]))}),super(...((e,t,n)=>{const r=new URL(e,location.href);return r.searchParams.set("reflected",t),[r,{...n,type:"module"}]})(e,"service",o)),super.addEventListener("message",()=>c(this),{once:!0}),super.postMessage(((e,t)=>{const n={};for(const e in t){const s=t[e];r(e)&&r(s)&&(n[e]=s)}return[e,n]})(g,o).concat(u)),this.#e=u}terminate(){a.delete(this.#e),super.terminate()}get channel(){return"service"}}const{parse:d,stringify:g}=JSON,{promise:h,resolve:p}=t();addEventListener("message",({data:[e,t,n]})=>p([e,t,n]),{once:!0});const y="service",f=(e,t,n)=>{const r=new BroadcastChannel(e),s=(()=>{const e=new Int32Array(1);return()=>e[0]++})(),{serviceWorker:a}=n;return(o,...c)=>{const i=s();r.postMessage([i,o],...c);const l=new XMLHttpRequest;return l.open("POST",a,!1),l.setRequestHeader("Content-Type","application/json"),l.send(g([i,e])),t.set(d(l.responseText),0),n.ondata(t.subarray(2,2+t[1]),...c)}};var w="importScripts"in globalThis?e=>h.then(([t,n,r])=>(postMessage(1),f(r,new Int32Array(t),{...n,...e}))):(e,n)=>{const{promise:r,resolve:s}=t();return new u(e,n,s),c.then(()=>r)};export{y as channel,w as default};

import{w as s}from"./with-resolvers-CHEvl4oe.js";import{i as e}from"./i32-C78nBJH2.js";import{r as t,s as a,d as n,b as r,u as o,S as c,t as i,T as h,h as u,v as f,n as l,B as p,F as b,i as g,k as y,j as m,E as d,m as w,M as k,D as A,p as x,w as B,V as U,x as v,N as O,U as S,q as j,g as q,Z as L,c as M,e as N,I as F,R as I,y as R,a as E,O as P,A as T}from"./channel-DQBWE7_E.js";import{b as z}from"./shared-D1EE5wug.js";const{isArray:D}=Array,_=s=>s;class J extends Worker{#s;#e;constructor(s,a){super(s,a),this.#s=e(),this.#e=new Map,a.onsend||(a.onsend=_),super.addEventListener("message",async s=>{const{data:e}=s;if(D(e)&&e[0]===t){s.stopImmediatePropagation(),s.preventDefault();const[t,n]=e[1],r=this.#e.get(t);this.#e.delete(t),r(await a.onsend(n))}})}send(e,...a){const n=this.#s(),{promise:r,resolve:o}=s();return this.#e.set(n,o),super.postMessage([t,[n,e]],...a),r}}class K{static push(s,e){s.sync(!1),s._(e,e.length)}constructor(s,e){const t=[];this.l=0,this.o=t,this.v=new Uint8Array(s,e),this.push=t.push.bind(t)}get length(){return this.l+this.o.length}sync(s){const e=this.o,t=e.length;t&&this._(s?e:e.splice(0),t)}_(s,e){const{buffer:t,byteOffset:a}=this.v,n=this.l;this.l+=e,e+=a+n,t.byteLength<e&&t.grow(e),this.v.set(s,n)}}const{getPrototypeOf:V}=Object,{construct:W}=Reflect,{toStringTag:Z}=Symbol,C=(s,e=s[Z])=>e in globalThis?e:C(W(V(s.constructor),[0])),{isNaN:G,isFinite:H,isInteger:Q}=Number,{ownKeys:X}=Reflect,{is:Y}=Object,$=(s,e,t)=>{const a=t.get(s),r=!a;return r?(n.setUint32(0,e.length,!0),t.set(s,[o[0],o[1],o[2],o[3]])):e.push(I,a[0],a[1],a[2],a[3]),r},ss=(s,e,t)=>{n.setUint32(0,t,!0),s.push(e,o[0],o[1],o[2],o[3])},es=(s,e,t)=>{switch(typeof s){case"number":s&&H(s)?Q(s)&&s<256&&-1<s?e.push(S,s):(n.setFloat64(0,s,!0),e.push(j,o[0],o[1],o[2],o[3],o[4],o[5],o[6],o[7])):G(s)?e.push(q):s?e.push(s<0?N:F):e.push(Y(s,0)?L:M);break;case"object":switch(!0){case null===s:e.push(O);break;case!$(s,e,t):break;case v(s):{const a=s.length;ss(e,T,a);for(let n=0;n<a;n++)es(s[n],e,t);break}case B(s):if(e.push(U),es(C(s),e,t),s=s.buffer,!$(s,e,t))break;case s instanceof ArrayBuffer:{const t=new Uint8Array(s);ss(e,x,t.length),as(e,t);break}case s instanceof Date:e.push(A),es(s.getTime(),e,t);break;case s instanceof Map:ss(e,k,s.size);for(const[a,n]of s)es(a,e,t),es(n,e,t);break;case s instanceof Set:ss(e,w,s.size);for(const a of s)es(a,e,t);break;case s instanceof Error:e.push(d),es(s.name,e,t),es(s.message,e,t),es(s.stack,e,t);break;case s instanceof y:e.push(m),es(s.data,e,t),es(s.width,e,t),es(s.height,e,t),es(s.colorSpace,e,t),es(s.pixelFormat,e,t);break;case s instanceof RegExp:e.push(g),es(s.source,e,t),es(s.flags,e,t);break;case s instanceof File:e.push(b),es(s.name,e,t),es(s.lastModified,e,t);case s instanceof Blob:{const a=s.size;e.push(p),es(s.type,e,t),es(a,e,t);const n=e.length;as(e,new Uint8Array(a)),ts.push(s.arrayBuffer().then(s=>[n,s]));break}default:if("toJSON"in s){const a=s.toJSON();es(a===s?null:a,e,t)}else{const a=X(s),n=a.length;ss(e,P,n);for(let r=0;r<n;r++){const n=a[r];es(n,e,t),es(s[n],e,t)}}}break;case"string":if($(s,e,t)){const t=f.encode(s);ss(e,l,t.length),as(e,t)}break;case"boolean":e.push(s?h:u);break;case"symbol":e.push(c),es(i(s),e,t);break;case"bigint":{let t=r;9223372036854775807n<s?(n.setBigUint64(0,s,!0),t=E):n.setBigInt64(0,s,!0),e.push(t,o[0],o[1],o[2],o[3],o[4],o[5],o[6],o[7]);break}default:e.push(a)}},ts=[];let as=R;const ns=({byteOffset:s=0,Array:e=K}={})=>(t,a)=>{const n=new e(a,s);as=e.push,es(t,n,new Map);const r=n.length;return n.sync(!0),ts.length?Promise.all(ts.splice(0)).then(e=>{const t=new Uint8Array(a,s);for(const[s,a]of e)t.set(new Uint8Array(a),s);return r}):r},{notify:rs,store:os}=Atomics,cs=({initByteLength:s=1024,maxByteLength:e=8192})=>new SharedArrayBuffer(z+s,{maxByteLength:z+e}),is=e=>(t,a)=>{const{promise:n,resolve:r}=s();return new e(t,a,r),n},hs=(s,e,t)=>{const a=new Int32Array(s),n=(e.encoder??ns)({byteOffset:z}),r=t?s=>{os(a,1,s),os(a,0,1),rs(a,0)}:s=>{a[1]=s,a[0]=1};return async({data:t})=>(e=>{const t=n(e,s);return"number"==typeof t?r(t):t.then(r)})(await e.onsync(t))},us=s=>{switch(typeof s){case"symbol":case"function":return!1}return!0},fs=(s,e)=>{const t={};for(const s in e){const a=e[s];us(s)&&us(a)&&(t[s]=a)}return[s,t]},ls=(s,e,t)=>{const a=new URL(s,location.href);return a.searchParams.set("reflected",e),[a,{...t,type:"module"}]};export{J as S,cs as a,is as b,hs as h,fs as p,ls as u};
